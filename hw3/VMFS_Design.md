## 虚拟文件系统 (VMFS) 设计方案

### 1. 引言

本文档描述了一个简单的虚拟文件系统 (VMFS) 的设计与实现。该文件系统在单个磁盘文件（`disk`）上模拟了基本的文件和目录操作，例如创建、删除、列出文件和目录，以及更改当前工作目录等。

#### 1.1 项目目的

1. 理解文件存储空间的管理；
2. 掌握文件的物理结构、目录结构和文件操作；
3. 实现简单文件系统管理；
4. 深文件系统实现过程的理解；

#### 1.2 开发环境

使用C++语言，在ubuntu 22.04操作系统环境下编译运行。

```bash
> make
```

或

```bash
> ./vmfs
```

运行

### 2. 系统架构

VMFS 采用基于块的存储方式，并将元数据和用户数据存储在预先分配的磁盘文件中。

#### 2.1. 磁盘布局

磁盘文件被划分为固定大小的块（默认为 4KB）。磁盘的初始部分用于存储文件系统的元数据：

* **块 0**: 根目录块。存储根目录的目录项。
* **块 1**: 位图 (Bitmap)。用于跟踪磁盘块的分配情况，每一位对应一个磁盘块，0 表示空闲，1 表示已分配。
* **块 2**: 文件分配表 (FAT)。一个数组，用于存储文件或目录占用的磁盘块链表。每个条目指向下一个块号，`FAT_END` (0xFFFFFFFF) 表示块链的结束。
* **后续块**: 用于存储目录项和文件数据。

#### 2.2. 核心数据结构

* `DirectoryEntry`: 定义了文件或目录的元数据。
  * `name[32]`: 文件或目录的名称。
  * `first_block`: 文件或目录的第一个数据块在 FAT 中的索引。
  * `size`: 文件的大小（字节）。对于目录，此字段通常为 0。
  * `is_directory`: 标记该条目是文件 (0) 还是目录 (1)。
* `bitmap`: 一个 `uint64_t` 类型的变量，用于表示磁盘块的分配状态。目前支持最多 64 个块。
* `fat_table[64]`: 一个 `size_t` 类型的数组，作为文件分配表。
* `cur`: 一个 `vector<pair<size_t, string>>`，用于跟踪当前工作目录的路径。每个 `pair` 存储了目录块号和目录名。
* `cur_path`: 一个 `string`，表示当前工作目录的完整路径。

### 3. 主要功能模块

#### 3.1. 初始化 (`init`)

* 如果 `disk` 文件不存在，则创建并初始化它。
* 将磁盘文件格式化为 64 个块，每块 4KB。
* 初始化位图，标记块 0、1、2 为已使用。
* 初始化 FAT，将根目录 (块 0) 标记为链表结束。
* 创建根目录，包含 "." (指向自身) 和 ".." (指向自身，因为是根目录) 两个条目。
* 将初始化后的位图、FAT 和根目录数据写入到 `disk` 文件对应的块中。

#### 3.2. 块操作

* `write_block(block_num, buffer, size)`: 将 `buffer` 中的数据写入到 `disk` 文件中指定的 `block_num` 块。
* `read_block(block_num, buffer, size)`: 从 `disk` 文件中指定的 `block_num` 块读取数据到 `buffer`。

#### 3.3. 文件和目录操作

* **`ls(block_num)`**: 列出指定 `block_num` 目录下的所有文件和目录。目录名以蓝色高亮显示。
* **`pwd(cur)`**: 根据当前的 `cur` 路径向量，生成并返回当前工作目录的字符串表示。
* **`cd(path, cur, cur_path)`**: 更改当前工作目录。
  * 支持绝对路径 (以 `/` 开头) 和相对路径。
  * 解析路径中的 "." 和 ".."。
  * 如果路径有效且目标是目录，则更新 `cur` 和 `cur_path`。
  * 如果路径无效或目标不是目录，则输出错误信息。
* **`create(file_path, cur, is_directory)`**: 创建文件或目录。
  * 解析 `file_path`，确定父目录。
  * 在位图中查找一个空闲块用于存储新的文件/目录数据。
  * 如果创建的是目录：
    * 检查父目录中是否已存在同名文件或目录。
    * 在新分配的块中创建 "." 和 ".." 目录项。
    * 在父目录中添加新目录的 `DirectoryEntry`。
  * 如果创建的是文件：
    * 检查父目录中是否已存在同名文件或目录。
    * 调用 `input` 函数获取用户输入作为文件内容。
    * 根据文件大小计算所需的块数。
    * 在位图中查找并分配足够的空闲块，并在 FAT 中建立块链。
    * 将文件内容写入分配的块中。
    * 在父目录中添加新文件的 `DirectoryEntry`。
  * 更新位图和 FAT 到磁盘。
* **`input(full_input)`**: 从用户处获取多行输入，直到用户输入一个空行为止。输入内容存储在 `full_input` 中。
* **`cat(file_path, cur)`**: 显示文件内容。
  * 解析 `file_path`，找到文件所在的目录和文件名。
  * 在目录中查找对应的文件条目。
  * 如果找到文件，则调用 `read_file` 读取文件内容，并调用 `output` 函数格式化输出。
  * 如果未找到文件，则输出错误信息。
* **`read_file(first_block, file_size)`**: 根据起始块号和文件大小，从磁盘读取完整的文件内容。
  * 通过 FAT 遍历文件的块链。
  * 从每个块中读取数据，直到读取完 `file_size` 指定的字节数。
* **`output(out, name)`**: 格式化并输出文件内容，包括行号，行号右对齐。
* **`rm(fileFirstBlock)`**: 删除文件。
  * 根据文件的起始块号，遍历 FAT 中的块链。
  * 清空每个数据块的内容（用 0 填充）。
  * 在 FAT 中将对应条目标记为空闲 (或链表结束)。
  * 在位图中将对应块标记为空闲。
  * 更新位图和 FAT 到磁盘。
  * **注意**: 此函数仅处理数据块和元数据，父目录中的 `DirectoryEntry` 需要在调用此函数前由 `findRmBlock` 处理。
* **`rm_r(rmDirBlock)`**: 递归删除目录及其内容。
  * 读取要删除目录的目录项。
  * 遍历目录中的每个条目：
    * 如果是子目录 (非 "." 或 "..")，则递归调用 `rm_r`。
    * 如果是文件，则调用 `rm` 删除文件。
    * 清空当前目录项。
  * 清空该目录自身的数据块。
  * 在位图中将该目录块标记为空闲。
  * 在 FAT 中将该目录块标记为空闲。
  * 更新位图和 FAT 到磁盘。
  * **注意**: 父目录中的 `DirectoryEntry` 需要在调用此函数前由 `findRmBlock` 处理。
* **`findParentDirBlock(file_path, cur)`**: 根据给定的文件/目录路径，找到其父目录的块号。
* **`findRmBlock(file_path, cur, is_dir)`**: 查找要删除的文件或目录的起始块号，并在其父目录中清除对应的 `DirectoryEntry`。
  * 调用 `findParentDirBlock` 找到父目录。
  * 在父目录中查找具有指定名称和类型的条目。
  * 如果找到，记录其 `first_block`，并将该 `DirectoryEntry` 清零。
  * 将修改后的父目录块写回磁盘。
  * 返回找到的块号，如果未找到则返回 `FAT_END` 并打印错误信息。

#### 3.4. 用户交互 (`main`)

* 程序入口点。
* 检查 `disk` 文件是否存在，如果不存在则调用 `init` 初始化。
* 打开 `disk` 文件，读取位图和 FAT 到内存。
* 进入命令循环，接收用户输入并分发到相应的处理函数。
* 支持的命令包括: `ls`, `cd`, `pwd`, `mkdir`, `touch`, `cat`, `rm`, `rm -r`, `man`, `quit`/`q`。
* 对于未知命令，会忽略该行剩余输入并提示错误。
* 退出时关闭文件描述符。

### 4. 错误处理和约束

* 使用 `assert` 进行关键操作的检查。
* 对用户操作（如 `cd` 到不存在的目录、创建重名文件/目录、`cat` 不存在的文件等）提供友好的错误提示。
* 文件名和目录名长度限制为 31 个字符 (因为 `DirectoryEntry.name` 大小为 32，需要一个字节存储 `\0`)。
* 文件系统总大小和最大文件数受限于位图和 FAT 的大小 (目前为 64 个块)。
* `input` 函数使用 `std::cin.ignore(2147483647, '\n');` 来清除命令输入后可能残留的换行符，确保 `getline` 能正确读取用户输入。
* 在未知命令处理中，使用 `cin.ignore(999,'\n');` 来丢弃无效命令行的剩余部分，防止影响下一次命令读取。

### 5. 项目演示

![](image\Snipaste_2025-06-14_12-58-22.png)
![](image\Snipaste_2025-06-14_12-59-25.png)
![](image\Snipaste_2025-06-14_13-00-36.png)![1749877533101](image/VMFS_Design/1749877533101.png)
