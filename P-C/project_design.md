# 生产者-消费者问题 C++ 实现设计方案

## 1. 项目概述

本项目旨在使用 C++ 标准库实现经典的生产者-消费者问题。生产者线程负责生成数据项并放入共享缓冲区，消费者线程负责从缓冲区取出数据项并进行处理。为了保证线程安全和同步，项目采用了信号量机制。

## 2. 项目需求 (根据代码和演示效果推断)

*   **功能需求:**
    *   实现一个固定大小的共享缓冲区 (大小为 20)。
    *   创建多个生产者线程和消费者线程。
    *   生产者向缓冲区放入数据 (1 到 20 的整数)。
    *   消费者从缓冲区取出数据。
    *   使用信号量 (`std::counting_semaphore`) 实现生产者和消费者之间的同步与互斥。
    *   程序启动时接收用户输入的生产者和消费者数量。
    *   在控制台动态、可视化地展示缓冲区的状态、生产者放入的数据以及消费者取出的数据。
*   **接口需求:**
    *   程序启动后提示用户输入生产者和消费者的数量。
    *   控制台输出应清晰展示缓冲区内容、生产者操作和消费者操作，使用不同颜色或符号区分。
*   **约束条件:**
    *   生产者数量 (`p`) 必须大于消费者数量 (`c`)。
    *   生产者数量与消费者数量之差 (`p - c`) 不能超过缓冲区大小 (20)。

## 3. 设计与实现

### 3.1 核心类 `Foo`

项目核心逻辑封装在 `Foo` 类中。

*   **成员变量:**
    *   `p`, `c`: 存储生产者和消费者的数量。
    *   `empty`: `std::counting_semaphore<20>`，初始值为 20，表示缓冲区空闲位置的数量。
    *   `full`: `std::counting_semaphore<20>`，初始值为 0，表示缓冲区中已用位置的数量。
    *   `lock`: `std::counting_semaphore<1>`，初始值为 1，用于实现对缓冲区的互斥访问。
    *   `producers`, `consumers`: `std::thread` 对象，分别代表生产者线程组和消费者线程组 (注：代码中实际只创建了一个生产者线程和一个消费者线程，但逻辑上支持多个)。
    *   `buffer`: `std::vector<int>`，大小为 20，作为共享缓冲区。
    *   `fill`: `int`，表示下一个要放入数据的位置索引 (或当前缓冲区中的项目数，取决于具体实现逻辑，代码中似乎混合使用)。
    *   `ptr_get`, `ptr_put`: `int`，用于控制台输出时追踪生产者和消费者打印的位置。

*   **成员函数:**
    *   `put()`: 生产者核心逻辑。向缓冲区放入数据，更新缓冲区状态，并调用 `printPut()` 在控制台显示。
    *   `get()`: 消费者核心逻辑。从缓冲区取出数据 (逻辑上)，更新缓冲区状态 (将对应位置显示为空)，并调用 `printGet()` 在控制台显示。
    *   `printPut()`: 在控制台的生产者行打印放入的数据（红色苹果图标）。
    *   `printGet()`: 在控制台的消费者行打印取出的数据（黄色苹果图标）。
    *   `producer(int p)`: 生产者线程函数。循环 `p` 次，每次尝试获取 `empty` 和 `lock` 信号量，调用 `put()`，然后释放 `lock` 和 `full` 信号量。
    *   `consumer(int c)`: 消费者线程函数。循环 `c` 次，每次尝试获取 `full` 和 `lock` 信号量，调用 `get()`，然后释放 `lock` 和 `empty` 信号量。
    *   `Foo(int p, int c)`: 构造函数。初始化成员变量，进行断言检查 (`p > c && p - c <= 20`)，初始化控制台界面，并创建启动生产者和消费者线程。
    *   `~Foo()`: 析构函数。等待生产者和消费者线程结束 (`join()`)，并调整控制台光标位置。

### 3.2 同步机制

*   **`empty` 信号量:** 控制生产者行为。当缓冲区满时 (`empty` 计数为 0)，生产者线程阻塞，直到有消费者取走数据并释放 `empty`。
*   **`full` 信号量:** 控制消费者行为。当缓冲区空时 (`full` 计数为 0)，消费者线程阻塞，直到有生产者放入数据并释放 `full`。
*   **`lock` 信号量:** 保证在任何时刻只有一个线程 (生产者或消费者) 能够访问和修改缓冲区及相关状态变量 (`fill`, `ptr_put`, `ptr_get`)，防止竞态条件。

### 3.3 控制台输出

*   使用了外部头文件 `cmd_console_tools.h` (推测包含 `cct_gotoxy` 等函数) 来控制光标位置。
*   使用 ANSI 转义序列 (`\033[...m`) 设置输出颜色 (红色用于生产者，黄色用于消费者)。
*   使用特定 Unicode 字符 (`\ue29e` - 苹果图标) 来可视化生产和消费的物品。
*   缓冲区状态通过 `____` 表示空位，通过带颜色和图标的数字表示占用的位置。

### 3.4 主函数 `main()`

*   提示用户输入生产者和消费者的数量。
*   读取用户输入。
*   创建 `Foo` 对象，传入生产者和消费者数量，启动整个过程。
*   `Foo` 对象的生命周期结束后 (生产者和消费者线程都执行完毕)，程序退出。

## 4. 使用说明

1.  **编译:** 需要 C++20 或以上版本的编译器 (因为使用了 `std::counting_semaphore`)。在 Visual Studio 中，直接构建项目即可。
2.  **运行:** 执行生成的可执行文件 (`P-C.exe` 或 `P-C`)。
3.  **输入:** 程序会提示 "Please input the number of producers and consumers:"。输入两个整数，分别代表生产者的生产次数和消费者的消费次数，用空格隔开 (例如 `20 10`)，然后按 Enter。
4.  **观察:** 控制台将动态显示生产者放入数据和消费者取出数据的过程。

## 5. 演示效果

程序的运行效果如下图所示 (根据提供的截图)：

